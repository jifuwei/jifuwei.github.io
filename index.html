<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
<meta name="referrer" content="unsafe-url" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="过刚易折，善柔不败">
<meta property="og:type" content="website">
<meta property="og:title" content="是咕咕鸡">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="是咕咕鸡">
<meta property="og:description" content="过刚易折，善柔不败">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="是咕咕鸡">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>是咕咕鸡</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?1575500ddb979a8e4e895121cbd848cb";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">是咕咕鸡</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">希望我分享的文章能够给每一位读者带来帮助！</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/30/yuque/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E2%80%94%E2%80%94%E5%B0%8F%E5%B0%8F%E7%9A%84log%E5%A4%A7%E5%A4%A7%E7%9A%84%E5%9D%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="是咕咕鸡">
      <meta itemprop="description" content="过刚易折，善柔不败">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="是咕咕鸡">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/30/yuque/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E2%80%94%E2%80%94%E5%B0%8F%E5%B0%8F%E7%9A%84log%E5%A4%A7%E5%A4%A7%E7%9A%84%E5%9D%91/" class="post-title-link" itemprop="url">性能调优——小小的log大大的坑</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-30 16:52:45" itemprop="dateCreated datePublished" datetime="2022-08-30T16:52:45+08:00">2022-08-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-02 16:23:10" itemprop="dateModified" datetime="2022-09-02T16:23:10+08:00">2022-09-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>“只有被线上服务问题毒打过的人才明白日志有多重要！”<br>我先说结论，谁赞成，谁反对？如果你深有同感，那恭喜你是个社会人了：）</p>
<p>日志对程序的重要性不言而喻，轻巧、简单、无需费脑，程序代码中随处可见，帮助我们排查定位一个有一个问题问题。但看似不起眼的日志，却隐藏着各式各样的“坑”，如果使用不当，不仅不能帮助我们，反而会成为服务“杀手”。<br>本文主要介绍生产环境日志使用不当导致的“坑”及避坑指北，高并发系统下尤为明显。同时提供一套实现方案能让程序与日志“和谐共处”。</p>
<h3 id="避坑指北"><a href="#避坑指北" class="headerlink" title="避坑指北"></a>避坑指北</h3><p>本章节我将介绍过往线上遇到的日志问题，并逐个剖析问题根因。</p>
<h4 id="不规范的日志书写格式"><a href="#不规范的日志书写格式" class="headerlink" title="不规范的日志书写格式"></a>不规范的日志书写格式</h4><p>场景</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 格式1</span></span><br><span class="line">log.debug(<span class="string">&quot;get user&quot;</span> + uid + <span class="string">&quot; from DB is Empty!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 格式2</span></span><br><span class="line"><span class="keyword">if</span> (log.isdebugEnable()) &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;get user&quot;</span> + uid + <span class="string">&quot; from DB is Empty!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 格式3</span></span><br><span class="line">log.debug(<span class="string">&quot;get user &#123;&#125; from DB is Empty!&quot;</span>, uid);</span><br></pre></td></tr></table></figure>

<p>如上三种写法，我相信大家或多或少都在项目代码中看到过，那么他们之前有区别呢，会对性能造成什么影响？<br>如果此时关闭 DEBUG 日志级别，差异就出现了，格式 1 依然还是要执行字符串拼接，即使它不输出日志，属于浪费。</p>
<p>格式 2 的缺点就是就在于需要加入额外的判断逻辑，增加了废代码，一点都不优雅。<br>所以推荐格式 3，只有在执行时才会动态的拼接，关闭相应日志级别后，不会有任何性能损耗。</p>
<h4 id="生产打印大量日志消耗性能"><a href="#生产打印大量日志消耗性能" class="headerlink" title="生产打印大量日志消耗性能"></a>生产打印大量日志消耗性能</h4><p>尽量多的日志，能够把用户的请求串起来，更容易断定出问题的代码位置。由于当前分布式系统，且业务庞杂，任何日志的缺失对于程序员定位问题都是极大的障碍。所以，吃过生产问题苦的程序员，在开发代码过程中，肯定是尽量多打日志。<br>为了以后线上出现问题能尽快定位问题并修复，程序员在编程实现阶段，就会尽量多打关键日志。那上线后是能快速定位问题了，但是紧接着又会有新的挑战：随着业务的快速发展，用户访问不断增多，系统压力越来越大，此时线上大量的 INFO 日志，尤其在高峰期，大量的日志磁盘写入，极具消耗服务性能。<br>那这就变成了博弈论，日志多了好排查问题，但是服务性能被“吃了”，日志少了服务稳定性没啥影响了，但是排查问题难了，程序员“苦”啊。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/694025/1661873455808-2f29dd48-b6cf-4709-b23f-c0e00f8945ff.png#clientId=u810b5934-dc6b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=244&id=u2a668ef2&margin=%5Bobject%20Object%5D&name=image.png&originHeight=488&originWidth=632&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=41010&status=done&style=none&taskId=u0ba7d5fb-82bf-4ec2-8700-b048f9a25fe&title=&width=316" alt="image.png"><br>提问：为何 INFO 日志打多了，性能会受损（此时 CPU 使用率很高）？</p>
<h5 id="根因一：同步打印日志磁盘-I-x2F-O-成为瓶颈，导致大量线程-Block"><a href="#根因一：同步打印日志磁盘-I-x2F-O-成为瓶颈，导致大量线程-Block" class="headerlink" title="根因一：同步打印日志磁盘 I&#x2F;O 成为瓶颈，导致大量线程 Block"></a>根因一：同步打印日志磁盘 I&#x2F;O 成为瓶颈，导致大量线程 Block</h5><p>可以想象，如果日志都输出到同一个日志文件时，此时有多个线程都往文件里面写，是不是就乱了套了。那解决的办法就是加锁，保证日志文件输出不会错乱，如果是在高峰期，锁的争抢无疑是最耗性能的。当有一个线程抢到锁后，其他的线程只能 Block 等待，严重拖垮用户线程，表现就是上游调用超时，用户感觉卡顿。</p>
<p>如下是线程卡在写文件时的堆栈</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Stack Trace is:</span><br><span class="line">java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">at org.apache.logging.log4j.core.appender.OutputStreamManager.writeBytes(OutputStreamManager.java:<span class="number">352</span>)</span><br><span class="line">- waiting to lock &lt;<span class="number">0x000000063d668298</span>&gt; (a org.apache.logging.log4j.core.appender.rolling.RollingFileManager)</span><br><span class="line">at org.apache.logging.log4j.core.layout.TextEncoderHelper.writeEncodedText(TextEncoderHelper.java:<span class="number">96</span>)</span><br><span class="line">at org.apache.logging.log4j.core.layout.TextEncoderHelper.encodeText(TextEncoderHelper.java:<span class="number">65</span>)</span><br><span class="line">at org.apache.logging.log4j.core.layout.StringBuilderEncoder.encode(StringBuilderEncoder.java:<span class="number">68</span>)</span><br><span class="line">at org.apache.logging.log4j.core.layout.StringBuilderEncoder.encode(StringBuilderEncoder.java:<span class="number">32</span>)</span><br><span class="line">at org.apache.logging.log4j.core.layout.PatternLayout.encode(PatternLayout.java:<span class="number">228</span>)</span><br><span class="line">.....</span><br></pre></td></tr></table></figure>

<p>那么是否线上减少 INFO 日志就没问题了呢？同样的，ERROR 日志量也不容小觑，假设线上出现大量异常数据，或者下游大量超时，瞬时会产生大量 ERROR 日志，此时还是会把磁盘 I&#x2F;O 压满，导致用户线程 Block 住。</p>
<p>提问：假设不关心 INFO 排查问题，是不是生产只打印 ERROR 日志就没性能问题了？</p>
<h5 id="根因二：高并发下日志打印异常堆栈造成线程-Block"><a href="#根因二：高并发下日志打印异常堆栈造成线程-Block" class="headerlink" title="根因二：高并发下日志打印异常堆栈造成线程 Block"></a>根因二：高并发下日志打印异常堆栈造成线程 Block</h5><p>有次线上下游出现大量超时，异常都被我们的服务捕获了，庆幸的是容灾设计时预计到会有这种问题发生，做了兜底值逻辑，本来庆幸没啥影响是，服务器开始“教做人”了。线上监控开始报警， CPU 使用率增长过快，CPU 一路直接增到 90%+ ，此时紧急扩容止损，并找一台拉下流量，拉取堆栈。<br>Dump 下来的线程堆栈查看后，结合火焰退分析，大部分现成都卡在如下堆栈位置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Stack Trace is:</span><br><span class="line">java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="number">404</span>)</span><br><span class="line">- waiting to lock &lt;<span class="number">0x000000064c514c88</span>&gt; (a java.lang.Object)</span><br><span class="line">at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:<span class="number">349</span>)</span><br><span class="line">at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="number">357</span>)</span><br><span class="line">at org.apache.logging.log4j.core.impl.ThrowableProxyHelper.loadClass(ThrowableProxyHelper.java:<span class="number">205</span>)</span><br><span class="line">at org.apache.logging.log4j.core.impl.ThrowableProxyHelper.toExtendedStackTrace(ThrowableProxyHelper.java:<span class="number">112</span>)</span><br><span class="line">at org.apache.logging.log4j.core.impl.ThrowableProxy.&lt;init&gt;(ThrowableProxy.java:<span class="number">112</span>)</span><br><span class="line">at org.apache.logging.log4j.core.impl.ThrowableProxy.&lt;init&gt;(ThrowableProxy.java:<span class="number">96</span>)</span><br><span class="line">at org.apache.logging.log4j.core.impl.Log4jLogEvent.getThrownProxy(Log4jLogEvent.java:<span class="number">629</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>此处堆栈较长，大部分现场全部 Block 在 <code>java.lang.ClassLoader.loadClass</code>，而且往下盘堆栈发现都是因为这行代码触发的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">at org.apache.logging.slf4j.Log4jLogger.error(Log4jLogger.java:<span class="number">319</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应的业务代码为</span></span><br><span class="line">log.error(<span class="string">&quot;ds fetcher get error&quot;</span>, e);</span><br></pre></td></tr></table></figure>

<p>啊这。。。就很离谱，你打个日志为何会加载类呢？加载类为何会 Block 这么多线程呢？<br>一番查阅分析后，得出如下结论：</p>
<ul>
<li>使用 Log4j 的 Logger.error 去打印异常堆栈的时候，为了打印出堆栈中类的位置信息，需要使用 Classloader 进行类加载；</li>
<li>Classloader 加载是线程安全的，虽然并行加载可以提高加载不同类的效率，但是多线程加载相同的类时，还是需要互相同步等待，尤其当不同的线程打印的异常堆栈完全相同时，就会增加线程 Block 的风险，而 Classloader 去加载一个无法加载的类时，效率会急剧下降，使线程 Block 的情况进一步恶化；</li>
<li>因为反射调用效率问题，JDK 对反射调用进行了优化，动态生成 Java 类进行方法调用，替换原来的 native 调用，而生成的动态类是由 DelegatingClassLoader 进行加载的，不能被其他的 Classloader 加载，异常堆栈中有反射优化的动态类，在高并发的条件下，就非常容易产生线程 Block 的情况。</li>
</ul>
<p>结合上文堆栈，卡在此处就很明清晰了：</p>
<ul>
<li>大量的线程涌进，导致下游的服务超时，使得超时异常堆栈频繁打印，堆栈的每一层，需要通过反射去拿对应的类、版本、行数等信息，<code>loadClass</code> 是需要同步等待的，一个线程加锁，导致大部分线程 block 住等待类加载成功，影响性能。</li>
<li>讲道理，即使大部分线程等待一个线程 <code>loadClass</code>，也只是一瞬间的卡顿，为何这个报错这会一直 <code>loadClass</code>类呢？结合上述结论分析程序代码，得出：此处线程内的请求下游服务逻辑包含 Groovy 脚本执行逻辑，属于动态类生成，上文结论三表明，动态类在高并发情况下，无法被 log4j 正确反射加载到，那么堆栈反射又要用，进入了死循环，越来越多的线程只能加入等待，block 住。</li>
</ul>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><h4 id="1-去掉不必要的异常堆栈打印"><a href="#1-去掉不必要的异常堆栈打印" class="headerlink" title="1. 去掉不必要的异常堆栈打印"></a>1. 去掉不必要的异常堆栈打印</h4><p>明显知道的异常，就不要打印堆栈，省点性能吧，任何事+高并发，意义就不一样了：）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(Integer.parseInt(number) + <span class="number">100</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 改进前</span></span><br><span class="line">    log.error(<span class="string">&quot;parse int error : &quot;</span> + number, e);</span><br><span class="line">    <span class="comment">// 改进后</span></span><br><span class="line">    log.error(<span class="string">&quot;parse int error : &quot;</span> + number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 Integer.parseInt 发生异常，导致异常原因肯定是出入的 number 不合法，在这种情况下，打印异常堆栈完全没有必要，可以去掉堆栈的打印。</p>
<h4 id="2-将堆栈信息转换为字符串再打印"><a href="#2-将堆栈信息转换为字符串再打印" class="headerlink" title="2. 将堆栈信息转换为字符串再打印"></a>2. 将堆栈信息转换为字符串再打印</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">stacktraceToString</span><span class="params">(Throwable throwable)</span> &#123;</span><br><span class="line">    <span class="type">StringWriter</span> <span class="variable">stringWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringWriter</span>();</span><br><span class="line">    throwable.printStackTrace(<span class="keyword">new</span> <span class="title class_">PrintWriter</span>(stringWriter));</span><br><span class="line">    <span class="keyword">return</span> stringWriter.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>log.error</code>得出的堆栈信息会更加完善，JDK 的版本，Class 的路径信息，jar 包中的类还会打印 jar 的名称和版本信息，这些都是去加载类反射得来的信息，极大的损耗性能。<br>调用 <code>stacktraceToString</code> 将异常堆栈转换为字符串，相对来说，确实了一些版本和 jar 的元数据信息，此时需要你自己决策取舍，到底是否有必要打印出这些信息（比如类冲突排查基于版本还是很有用的）。</p>
<h4 id="3-禁用反射优化"><a href="#3-禁用反射优化" class="headerlink" title="3. 禁用反射优化"></a>3. 禁用反射优化</h4><p>使用 Log4j 打印堆栈信息，如果堆栈中有反射优化生成的动态代理类，这个代理类不能被其它的 Classloader 加载，这个时候打印堆栈，会严重影响执行效率。但是禁用反射优化也会有副作用，导致反射执行的效率降低。</p>
<h4 id="4-异步打印日志"><a href="#4-异步打印日志" class="headerlink" title="4.异步打印日志"></a>4.异步打印日志</h4><p>生产环境，尤其是 QPS 高的服务，一定要开启异步打印，当然开启异步打印，有一定丢失日志的可能，比如服务器强行“杀死”，这也是一个取舍的过程。</p>
<h4 id="5-日志的输出格式"><a href="#5-日志的输出格式" class="headerlink" title="5. 日志的输出格式"></a>5. 日志的输出格式</h4><p>我们看戏日志输出格式区别</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 格式1</span></span><br><span class="line">[%d&#123;yyyy/MM/dd HH:mm:ss.SSS&#125;[%X&#123;traceId&#125;] %t [%p] %C&#123;<span class="number">1</span>&#125; (%F:%M:%L) %msg%n</span><br><span class="line"></span><br><span class="line"><span class="comment">// 格式2</span></span><br><span class="line">[%d&#123;yy-MM-dd.HH:mm:ss.SSS&#125;] [%thread]  [%-5p %-22c&#123;<span class="number">0</span>&#125; -] %m%n</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://logging.apache.org/log4j/2.x/performance.html#asyncLoggingWithLocation">官网</a>也有明确的性能对比提示，如果使用了如下字段输出，将极大的损耗性能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%C or $class, %F or %file, %l or %location, %L or %line, %M or %method</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2022/png/694025/1661944352416-b1eca6dd-4441-4001-80e5-d3f61b7264d1.png#clientId=u810b5934-dc6b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=616&id=uc84ae27d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1232&originWidth=2328&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=409683&status=done&style=none&taskId=uf6f24a72-1129-48c7-a6ba-ef9cf1a33ad&title=&width=1164" alt="image.png"><br>log4j 为了拿到函数名称和行号信息，利用了异常机制，首先抛出一个异常，之后捕获异常并打印出异常信息的堆栈内容，再从堆栈内容中解析出行号。而实现源码中增加了锁的获取及解析过程，高并发下，性能损耗可想而知。</p>
<p>如下是比较影响性能的参数配置，请大家酌情配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%C - 调用者的类名(速度慢,不推荐使用)</span><br><span class="line">%F - 调用者的文件名(速度极慢,不推荐使用)</span><br><span class="line">%l - 调用者的函数名、文件名、行号(极度不推荐，非常耗性能)</span><br><span class="line">%L - 调用者的行号(速度极慢,不推荐使用)</span><br><span class="line">%M - 调用者的函数名(速度极慢,不推荐使用)</span><br></pre></td></tr></table></figure>

<h3 id="解决方案——日志级别动态调整"><a href="#解决方案——日志级别动态调整" class="headerlink" title="解决方案——日志级别动态调整"></a>解决方案——日志级别动态调整</h3><p>项目代码需要打印大量 <code>INFO</code>级别日志，以支持问题定位及测试排查等。但这些大量的 <code>INFO</code>日志对生产环境是无效的，大量的日志会吃掉 CPU 性能，此时需要能动态调整日志级别，既满足可随时查看 <code>INFO</code>日志，又能满足不需要时可动态关闭，不影响服务性能需要。</p>
<p>方案：结合 Apollo 及 log4j2 特性，从 api 层面，动态且细粒度的控制全局或单个 Class 文件内的日志级别。优势是随时生效，生产排查问题，可指定打开单个 class 文件日志级别，排查完后可随时关闭。</p>
<p>限于本篇篇幅，具体实现代码就不贴出了，其实实现很简单，就是巧妙的运用 Apollo 的动态通知机制去重置日志级别，如果大家感兴趣的话，可以私信或者留言我，我开一篇文章专门来详细讲解如何实现。</p>
<h3 id="总结与展望"><a href="#总结与展望" class="headerlink" title="总结与展望"></a>总结与展望</h3><p>本篇带你了解了日志在日常软件服务中常见的问题，以及对应的解决方法。切记，简单的东西 + 高并发 &#x3D; 不简单！要对生产保持敬畏之心！</p>
<p>能读到结尾说明你真是铁粉了，有任何问题请私信或者评论，我看到了一定会第一时间回复。如果你觉得本人分享的内容够“干”，麻烦点赞、关注、转发，这是对我最大鼓励，感谢支持！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/28/yuque/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%BF%85%E5%A4%87%E2%80%94%E2%80%94%E7%81%AB%E7%84%B0%E5%9B%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="是咕咕鸡">
      <meta itemprop="description" content="过刚易折，善柔不败">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="是咕咕鸡">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/28/yuque/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%BF%85%E5%A4%87%E2%80%94%E2%80%94%E7%81%AB%E7%84%B0%E5%9B%BE/" class="post-title-link" itemprop="url">性能优化必备——火焰图</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-28 14:38:15" itemprop="dateCreated datePublished" datetime="2022-08-28T14:38:15+08:00">2022-08-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-02 16:23:10" itemprop="dateModified" datetime="2022-09-02T16:23:10+08:00">2022-09-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>本文主要介绍火焰图及使用技巧，学习如何使用火焰图快速定位软件的性能卡点。<br>结合最佳实践实战案例，帮助读者加深刻的理解火焰图构造及原理，理解 CPU 耗时，定位性能瓶颈。</p>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><h4 id="当前现状"><a href="#当前现状" class="headerlink" title="当前现状"></a>当前现状</h4><p>假设没有火焰图，你是怎么调优程序代码的呢？让我们来捋一下。</p>
<h5 id="1-功能开关法"><a href="#1-功能开关法" class="headerlink" title="1. 功能开关法"></a>1. 功能开关法</h5><p>想当年我刚工作，还是一个技术小白时，排查问题只能靠玄学，大致能猜出问题可能是由某个功能代码导致的，此时的排查手段就是删除多余的功能代码，然后再运行查看 CPU 消耗，确定问题。（至今我工作时还会发现一些老人使用如此方法调试性能。）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (关闭<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 功能1</span></span><br><span class="line">        handle1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (关闭<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 功能2</span></span><br><span class="line">        handle2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (打开<span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">// 功能3</span></span><br><span class="line">        handle3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 功能4</span></span><br><span class="line">    handle4();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此法全靠“经验”和“运气”，而且改动了代码结构，假设这是一个已经通过测试的集成区代码，此时需要修改代码功能来调试程序是非常危险的一件事，当然有 Git 仓库可以“一键还原”，但是，是人操作，总归会有失手的时候，且定位效率太低</p>
<h5 id="2-StopWatch-埋点法"><a href="#2-StopWatch-埋点法" class="headerlink" title="2. StopWatch 埋点法"></a>2. StopWatch 埋点法</h5><p>当程序出现性能问题时，且不确定是哪一段代码导致耗时，可以借助方法耗时来判断，此时我们只要在调用方法前后追加执行所需耗时日志，即可判定到底是哪个方法最耗时。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Stopwatch</span> <span class="variable">stopwatch</span> <span class="operator">=</span> Stopwatch.createStarted();</span><br><span class="line">    handle1();</span><br><span class="line">	log.info(<span class="string">&quot;method handle1 cost: &#123;&#125; ms&quot;</span>,</span><br><span class="line">             stopwatch.elapsed(TimeUnit.MILLISECONDS));</span><br><span class="line"></span><br><span class="line">    handle2();</span><br><span class="line">    log.info(<span class="string">&quot;method handle2 cost: &#123;&#125; ms&quot;</span>,</span><br><span class="line">             stopwatch.elapsed(TimeUnit.MILLISECONDS));</span><br><span class="line"></span><br><span class="line">    handle3();</span><br><span class="line">    log.info(<span class="string">&quot;method handle3 cost: &#123;&#125; ms&quot;</span>,</span><br><span class="line">             stopwatch.elapsed(TimeUnit.MILLISECONDS));</span><br><span class="line"></span><br><span class="line">    handle4();</span><br><span class="line">    log.info(<span class="string">&quot;method handle4 cost: &#123;&#125; ms&quot;</span>,</span><br><span class="line">             stopwatch.stop().elapsed(TimeUnit.MILLISECONDS));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此法较上一个方法的优势是，不改变代码的逻辑情况下，只是增强了一些观测点位，由方法的耗时来定位性能瓶颈。但是，假设方法的处理调用栈很深，就不得不在子方法中再次埋点，此时判定流程即为：埋点 -&gt; 发版 -&gt; 定位 -&gt; 埋点 -&gt; 发版 -&gt; 定位 -&gt; …….且本质上也是改了代码，就有出错的可能。 心累，不高效！</p>
<h5 id="3-TOP-命令定位热线程"><a href="#3-TOP-命令定位热线程" class="headerlink" title="3. TOP 命令定位热线程"></a>3. TOP 命令定位热线程</h5><p>一般企业的软件服务都是部署在 Linux 操作系统上，有经验的老手排查性能最方便的办法就是 top 定位。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -p pid -H</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2022/png/694025/1661688744009-65e104d7-9147-46d7-9cd4-690e90a56fe3.png#clientId=u9ad7ae42-3657-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=317&id=uef075c25&margin=%5Bobject%20Object%5D&name=image.png&originHeight=633&originWidth=1500&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=161692&status=done&style=none&taskId=u205ed8aa-ad91-43ad-b320-d9cc38eb6b6&title=&width=750" alt="image.png"><br>明显看到，pid 103 消耗了 40%的 CPU, 找到对应的 stack 线程信息如下（忽略查找办法，我假设你已经会了：））：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/694025/1661688843364-ff4d6c31-4b19-48b1-a7ec-81a15c4fb88f.png#clientId=u9ad7ae42-3657-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=374&id=u1c931506&margin=%5Bobject%20Object%5D&name=image.png&originHeight=747&originWidth=1500&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=415366&status=done&style=none&taskId=u8f0d33a9-73a3-423f-8f57-11d6029a2a3&title=&width=750" alt="image.png"><br>此时可以得出结论，当前最耗 CPU 的线程是写入磁盘文件，追查代码最终会定位到是因为在高并发场景下打了大量的 INFO 日志，导致磁盘写入成为瓶颈。</p>
<p>总结：TOP 命令对于找 CPU 性能瓶颈时很有效的，但是存在如下几个问题：</p>
<ul>
<li>排名最前的一定是当时最消耗 CPU 的，但不一定是程序性能的诱因。例如因某个 BUG 导致打印了大量 ERROR 日志，最终 LOG 到磁盘是最消耗 CPU 的，但罪魁祸首不是它。</li>
<li>TOP 注定使你只会关注最高的，等你修复最耗 CPU 的问题后，往往还会遇到别的程序问题导致 CPU 偏高，即一次只能看到一个问题，看不到全貌。</li>
<li>文本的表现力非常有限：首先你得对 Linux 及 JVM 命令非常熟悉，其次文本对两个及以上值做关联性分析时，就捉襟见肘了，此时就迫切的需要另一种分析工具——图。</li>
</ul>
<h3 id="什么是火焰图"><a href="#什么是火焰图" class="headerlink" title="什么是火焰图"></a>什么是火焰图</h3><p>火焰图（<a target="_blank" rel="noopener" href="https://www.brendangregg.com/flamegraphs.html">Flame Graphs</a>），因其形似火焰而得名。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/694025/1661671460480-032bb8c9-3b60-46ae-92f6-7a005650766a.png#clientId=u9ad7ae42-3657-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=420&id=BVTc9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=840&originWidth=1180&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=158583&status=done&style=none&taskId=u8163d14c-9655-463f-af35-da8cd2e0938&title=&width=590" alt="image.png"></p>
<p>如上就是一个典型的火焰图，它由各种大小&#x2F;颜色的方块组成，每个方块内部还标识了文字，整个图片顶部凹凸不平，形似一簇簇“火苗”，因此得名火焰图。<br>火焰图是 SVG 生成，因此可以与用户互动，鼠标悬浮在某个方块时，会详细展示内部文字。点击后，即会以当前被点击方块为底向上展开。</p>
<p><strong>特征</strong><br>使用火焰图分析之前，我们得首先了解火焰图的基本构造</p>
<ul>
<li>每一列代表一个调用栈，每一格代表一个被调用函数</li>
<li>方块上的字符标识调用方法，数字表示当前采样出现次数</li>
<li>Y 轴表示调用栈深度，X 轴将多个调用栈归并，并首字母排序展示</li>
<li>X 轴宽度表示采样数据中出现频次，即宽度越大，导致性能瓶颈的原因可能就越大（<strong>注意：是可能，不是确定</strong>）</li>
<li>颜色没什么意义，随机分配（可能创始人想让你看起来更像一个火焰。。）</li>
</ul>
<h3 id="火焰图可以做什么"><a href="#火焰图可以做什么" class="headerlink" title="火焰图可以做什么"></a>火焰图可以做什么</h3><p>那此时你已经知道了火焰图，如何定位软件问题呢？我们需要一套寻找性能瓶颈的方法论。<br>可以明确的是 CPU 消耗高的口径</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CPU 消耗高的口径 = 调用栈出现频率最高的一定是吃 CPU 的</span><br></pre></td></tr></table></figure>

<p>如上我们已经知道了火焰图的构造，及“物料”含义，此时我们的关注点应该在方形的宽度上，方形的宽度大小代表了该调用栈在整个抽样历史中出现的次数。次数意味着频率，即出现次数越多的即可能最消耗 CPU。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/694025/1661691385319-4a4924d1-bd2b-4a65-8e5d-6da1584e38d8.png#clientId=u9ad7ae42-3657-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=180&id=u5ab13912&margin=%5Bobject%20Object%5D&name=image.png&originHeight=360&originWidth=1180&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=132710&status=done&style=none&taskId=ud3140623-bdb6-400e-a9c4-abb7cf37591&title=&width=590" alt="image.png"><br>但只关注最长的是没用的，如底部的 root 和中部的方块都很宽，只能说明这些方法是“入口方法”，即每次发起调用都会经过的方法。<br>我们更应该关注火焰山顶部的”<strong>平顶山</strong>“（plateaus）<strong>出现的次数多，即没有子调用</strong>，抽样出现的频率高，说明执行方法的时间较长，或者执行频率太高（如长轮询），即 CPU 大部分执行都分配给了“平顶山”，它才是性能瓶颈的根因。</p>
<p><strong>总结方法论：火焰图看“平顶山”，山顶的函数可能存在性能问题！</strong></p>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>实践是检验真理的唯一标准！下面我将以一个小的 Demo 来展示如何定位程序性能问题，加深对火焰图使用的理解。</p>
<p>Demo 程序如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            executorService.submit(Demo::handle1);</span><br><span class="line">            executorService.submit(Demo::handle2);</span><br><span class="line">            executorService.submit(Demo::handle3);</span><br><span class="line">            executorService.submit(Demo::handle4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handle4</span><span class="params">()</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handle2</span><span class="params">()</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">50</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handle3</span><span class="params">()</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handle1</span><span class="params">()</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">50</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很简单，当然现实中也不会这么写，主要是配合演出。。<br>主要是开了一个线程池，且分别执行四个 task，不同的 task 耗时不一致，此时我们的性能瓶颈在 handle4 这个任务上，在知道结论的前提下，我们比较看火焰图得出答案的是否符合预期！</p>
<h4 id="1-JVM-堆栈信息拉取"><a href="#1-JVM-堆栈信息拉取" class="headerlink" title="1. JVM 堆栈信息拉取"></a>1. JVM 堆栈信息拉取</h4><p>当前我是在自己的 Mac 上运行的程序，idea 执行这一段程序非常便捷，那如何获取当前运行 main 函数的 PID？<br>此时需要用到 TOP 命令，上面是个 while 死循环，很明显吃 CPU 最厉害，只要找到归属 Java 线程的最高一个 PID 即为所求。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/694025/1661695122289-4c145746-c1fa-4538-91ec-819ead1a9a69.png#clientId=u9ad7ae42-3657-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=394&id=uc9880799&margin=%5Bobject%20Object%5D&name=image.png&originHeight=788&originWidth=2796&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=253812&status=done&style=none&taskId=ud4d557b3-5950-40bb-8625-8850ecab57c&title=&width=1398" alt="image.png"><br>很明显得到 COMMAND &#x3D; java 最高的 PID &#x3D; 20552<br>此时执行如下命令获取堆栈信息，并写入 tmp.txt 文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack -l 20552 &gt; tmp.txt</span><br></pre></td></tr></table></figure>

<h4 id="2-生成火焰图"><a href="#2-生成火焰图" class="headerlink" title="2. 生成火焰图"></a>2. 生成火焰图</h4><p>生成火焰图的工具有很多，我一般会借助 <a target="_blank" rel="noopener" href="https://www.fastthread.io/">FastThread</a>，在线分析堆栈，非常方便，同时支持生成火焰图，方便我们定位问题<br><img src="https://cdn.nlark.com/yuque/0/2022/png/694025/1661695607939-14cdffb8-c2f7-49c7-a3e1-4e9565fa17b3.png#clientId=u9ad7ae42-3657-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=747&id=u2bcb252e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1494&originWidth=2878&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=1793108&status=done&style=none&taskId=u8ea4ae74-09ed-4d88-8327-03d74ead781&title=&width=1439" alt="image.png"><br>打开官网首页，选择刚刚 dump 的堆栈文件，点击 Analyze，此时只需要等待网站分析好后（正常 3~5 s），即可查看火焰图</p>
<p>fastThread 网站分析报告非常丰富，一般的问题我们直接通过它给出的结论基本能定位到问题了，本文暂且无需关注，感兴趣的话，后续我会分享，直接拉到 Flame Graph 子标题处<br><img src="https://cdn.nlark.com/yuque/0/2022/png/694025/1661696145023-9007ea97-b3f5-47db-86c5-663ccbfe25a2.png#clientId=u9ad7ae42-3657-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=453&id=u779713d9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=906&originWidth=2348&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=220987&status=done&style=none&taskId=uddc72cae-8b9a-433e-8fa9-a0b84a3f1ff&title=&width=1174" alt="image.png"><br>此时明显能看出 4 个“平顶山”，且 com.Demo.handle4 宽度最大，com.Demo.handle3 次之，符合预期！</p>
<h3 id="原理剖析"><a href="#原理剖析" class="headerlink" title="原理剖析"></a>原理剖析</h3><p>基于上述小 Demo ，我们深入理解下火焰图的生成原理。</p>
<p>举个例子，便于你理解，假设我们要观测一个人在忙些什么，哪些事最占用他的时间，会怎么做？<br>从时间维度的话，且不考虑成本的话，我肯定安排一个监控摄像头，全天候 24h，360 度监控他，然后再安排人员，逐帧排查，并汇总他所做的事，得出：睡觉 8h，工作 8h，玩手机 4h，吃饭 2h，其它 2h。从而得出结论：睡觉占用他时间最多。</p>
<p>由上可以总结一套分析流程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">记录（监控）-&gt; 分析&amp;归并（逐帧排查） -&gt;  Top N -&gt; 得出结论</span><br></pre></td></tr></table></figure>

<p>带着流程去看我们应该如何排查 CPU 在执行中，哪些事（进程&#x2F;线程）最占用它的时间呢？<br>简单粗暴的方法是每时每刻都记录执行的方法堆栈，再汇总归并，得出最耗时的方法栈在哪。此法的问题在于</p>
<ul>
<li>数据量大</li>
<li>时间长</li>
</ul>
<p>其实只要采样去观测 CPU 在干什么就好了，这是一个概率学问题，如果 CPU 因为执行某个方法耗时，大概率采样下来，得到的归并结果也是最多的，虽然有误差，但是多次统计下，差不了多少的。<br>同理，dump 下的堆栈，查看大多数线程在干什么，依据堆栈内每个方法出现的频率聚合，出现的频次最多的就是当前 CPU 分配执行最多的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;pool-1-thread-18&quot;</span> #<span class="number">28</span> prio=<span class="number">5</span> os_prio=<span class="number">31</span> tid=<span class="number">0x00007f9a8d4c0000</span> nid=<span class="number">0x8d03</span> sleeping[<span class="number">0x000000030be59000</span>]</span><br><span class="line">    java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class="line">    at java.lang.Thread.sleep(Native Method)</span><br><span class="line">    at com.Demo.handle2(Demo.java:<span class="number">31</span>)</span><br><span class="line">    at com.Demo$$Lambda$<span class="number">2</span>/<span class="number">1277181601.</span>run(Unknown Source)</span><br><span class="line">    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:<span class="number">511</span>)</span><br><span class="line">    at java.util.concurrent.FutureTask.run(FutureTask.java:<span class="number">266</span>)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1149</span>)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">624</span>)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"></span><br><span class="line">    Locked ownable synchronizers:</span><br><span class="line">- &lt;<span class="number">0x00000006c6921ac0</span>&gt; (a java.util.concurrent.ThreadPoolExecutor$Worker)</span><br></pre></td></tr></table></figure>

<p>至于我们的 jstack 信息如何被处理成火焰图的格式，社区已经为常见的 dump 格式都提供了工具，<a target="_blank" rel="noopener" href="https://github.com/brendangregg/FlameGraph/blob/master/stackcollapse-jstack.pl">stackcollapse-jstack.pl</a> 处理 jstack 输出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Example input:</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;MyProg&quot;</span> #<span class="number">273</span> daemon prio=<span class="number">9</span> os_prio=<span class="number">0</span> tid=<span class="number">0x00007f273c038800</span> nid=<span class="number">0xe3c</span> runnable [<span class="number">0x00007f28a30f2000</span>]</span><br><span class="line">    java.lang.Thread.State: RUNNABLE</span><br><span class="line">        at java.net.SocketInputStream.socketRead0(Native Method)</span><br><span class="line">        at java.net.SocketInputStream.read(SocketInputStream.java:<span class="number">121</span>)</span><br><span class="line">        ...</span><br><span class="line">        at java.lang.Thread.run(Thread.java:<span class="number">744</span>)</span><br><span class="line"></span><br><span class="line">Example output:</span><br><span class="line"></span><br><span class="line">MyProg;java.lang.Thread.run;java.net.SocketInputStream.read;java.net.SocketInputStream.socketRead0 <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="总结-amp-展望"><a href="#总结-amp-展望" class="headerlink" title="总结&amp;展望"></a>总结&amp;展望</h3><p>火焰图的介绍到此结束，相信你又多了一种排查问题的手段！<br>存在即合理，工具之开发重要性而言不必多说，我始终持包容态度面对新事物，它确确实实解决了某些痛点而脱颖而出的。<br>后续我会介绍更多排查问题的手段，如果你喜欢本文风格，请关注或留言，欢迎讨论！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/05/yuque/Flink%20%E5%9C%A8%E9%A3%8E%E6%8E%A7%E5%9C%BA%E6%99%AF%E5%AE%9E%E6%97%B6%E7%89%B9%E5%BE%81%E8%90%BD%E5%9C%B0%E5%AE%9E%E6%88%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="是咕咕鸡">
      <meta itemprop="description" content="过刚易折，善柔不败">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="是咕咕鸡">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/05/yuque/Flink%20%E5%9C%A8%E9%A3%8E%E6%8E%A7%E5%9C%BA%E6%99%AF%E5%AE%9E%E6%97%B6%E7%89%B9%E5%BE%81%E8%90%BD%E5%9C%B0%E5%AE%9E%E6%88%98/" class="post-title-link" itemprop="url">Flink 在风控场景实时特征落地实战</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-05 14:58:48" itemprop="dateCreated datePublished" datetime="2021-11-05T14:58:48+08:00">2021-11-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-02 16:23:10" itemprop="dateModified" datetime="2022-09-02T16:23:10+08:00">2022-09-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h3><h4 id="风控简介"><a href="#风控简介" class="headerlink" title="风控简介"></a>风控简介</h4><p>二十一世纪，信息化时代到来，互联网行业的发展速度远快于其他行业。一旦商业模式跑通，有利可图，资本立刻蜂拥而至，助推更多企业不断的入场进行快速的复制迭代，企图成为下一个“行业领头羊”。</p>
<p>带着资本入场的玩家因为不会有资金的压力，只会更多的关注业务发展，却忽略了业务上的风险点。强大如拼多多也被“薅羊毛”大军光顾损失千万。</p>
<p>风控，即风险管理（risk management），是一个管理过程，包括对风险的定义、测量、评估和应对风险的策略。目的是将可避免的风险、成本及损失极小化[1]。</p>
<h4 id="特征平台简介"><a href="#特征平台简介" class="headerlink" title="特征平台简介"></a>特征平台简介</h4><p>互联网企业每时每刻都面临着黑灰产的各种攻击。业务安全团队需要事先评估业务流程中有风险的地方，再设置卡点，用来采集相关业务信息，识别当前请求是否有风险。专家经验（防控策略）就是在长期以往的对抗中产生的。</p>
<p>策略的部署需要一个个特征来支持，那什么是特征？<br>特征分为基础型特征、衍生型特征、统计型特征等，举例如下：</p>
<ul>
<li>基础型特征：可以直接从业务获取的，如订单的金额、买家的手机号码、买家地址、卖家地址等</li>
<li>衍生特征：需要二次计算，如买家到买家的距离、手机号前 3 位等</li>
<li>统计型特征：需要实时统计的，如 5 分钟内某手机号下购买订单数、10 分钟内购买金额大于 2w 元订单数等</li>
</ul>
<p>随着业务的迅猛发展，单纯的专家经验已不能满足风险识别需求，算法团队的加入使得拦截效果变得更加精准。算法部门人员通过统一算法工程框架，解决了模型和特征迭代的系统性问题，极大地提升了迭代效率。</p>
<p>根据功能不同，算法平台可划分为三部分：模型服务、模型训练和特征平台。其中，模型服务用于提供在线模型预估，模型训练用于提供模型的训练产出，特征平台则提供特征和样本的数据支撑。本文将重点阐述特征平台在建设过程中实时计算遇到的挑战以及优化思路。</p>
<h3 id="挑战与方案"><a href="#挑战与方案" class="headerlink" title="挑战与方案"></a>挑战与方案</h3><h4 id="面临的挑战"><a href="#面临的挑战" class="headerlink" title="面临的挑战"></a>面临的挑战</h4><p>业务发展的初期，我们可以通过硬编码的方式满足策略人员提出的特征需求，协同也比较好。但随着业务发展越来越快，业务线越来越多，营销玩法越来越复杂，用户数和请求量成几何倍上升。适用于早期的硬编码方式出现了策略分散无法管理、逻辑同业务强耦合、策略更新迭代率受限于开发、对接成本高等多种问题。此时，我们急需一套线上可配置、可热更新、可快速试错的特征管理平台。</p>
<h4 id="旧框架的不足"><a href="#旧框架的不足" class="headerlink" title="旧框架的不足"></a>旧框架的不足</h4><h5 id="实时框架-1-0：基于-Flink-DataStream-API-构建"><a href="#实时框架-1-0：基于-Flink-DataStream-API-构建" class="headerlink" title="实时框架 1.0：基于 Flink DataStream API 构建"></a>实时框架 1.0：基于 Flink DataStream API 构建</h5><p>如果你熟悉 Flink DataStream API，那你肯定会发现 Flink 的设计天然满足风控实时特征计算场景，我们只需要简单的几步即可统计指标，如下图所示：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/694025/1636554028139-4a8ffd52-fb76-474f-8765-51b1f36ece82.png#clientId=u0e262297-22b8-4&from=paste&height=450&id=RcUmn&margin=%5Bobject%20Object%5D&name=flink-dataStream-api.png&originHeight=900&originWidth=868&originalType=binary%E2%88%B6=1&size=79647&status=done&style=none&taskId=ud09dd734-0830-453a-81dc-3ea456fb68d&width=434" alt="flink-dataStream-api.png"><br>Flink DataStream 流图</p>
<p>实时特征统计样例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据流，如topic</span></span><br><span class="line">DataStream&lt;ObjectNode&gt; dataStream = ...</span><br><span class="line"></span><br><span class="line">SingleOutputStreamOperator&lt;AllDecisionAnalyze&gt; windowOperator = dataStream</span><br><span class="line">				<span class="comment">// 过滤</span></span><br><span class="line">                .filter(<span class="built_in">this</span>::filterStrategy)</span><br><span class="line">    			<span class="comment">// 数据转换</span></span><br><span class="line">                .flatMap(<span class="built_in">this</span>::convertData)</span><br><span class="line">    			<span class="comment">// 配置watermark</span></span><br><span class="line">                .assignTimestampsAndWatermarks(timestampAndWatermarkAssigner(config))</span><br><span class="line">    			<span class="comment">// 分组</span></span><br><span class="line">                .keyBy(<span class="built_in">this</span>::keyByStrategy)</span><br><span class="line">    			<span class="comment">// 5分钟滚动窗口</span></span><br><span class="line">                .window(TumblingEventTimeWindows.of(Time.seconds(<span class="number">300</span>)))</span><br><span class="line">    			<span class="comment">// 自定义聚合函数，内部逻辑自定义</span></span><br><span class="line">                .aggregate(AllDecisionAnalyzeCountAgg.create(), AllDecisionAnalyzeWindowFunction.create());</span><br></pre></td></tr></table></figure>

<p>1.0 框架不足：</p>
<ul>
<li>特征强依赖开发人员编码，简单的统计特征可以抽象，稍微复杂点就需要定制</li>
<li>迭代效率低，策略提需求、产品排期、研发介入、测试保障、一套流程走完交付最少也是两周</li>
<li>特征强耦合，任务拆分难，一个 JOB 包含太多逻辑，可能新上的特征逻辑会影响之前稳定的指标</li>
</ul>
<p>总的来说，1.0 在业务初期很适合，但随着业务发展，研发速度逐渐成为瓶颈，不符合可持续、可管理的实时特征清洗架构。</p>
<h5 id="实时框架-2-0：基于-Flink-SQL-构建"><a href="#实时框架-2-0：基于-Flink-SQL-构建" class="headerlink" title="实时框架 2.0：基于 Flink SQL 构建"></a>实时框架 2.0：基于 Flink SQL 构建</h5><p>1.0 架构的弊端在于需求到研发采用不同的语言体系，如何高效的转化需求，甚至是直接让策略人员配置特征清洗逻辑直接上线？如果按照两周一迭代的速度，可能线上早被黑灰产薅的“面目全非”了。</p>
<p>此时我们研发团队注意到 Flink SQL，SQL 是最通用的数据分析语言，数分、策略、运营基本必备技能，可以说 SQL 是转换需求代价最小的实现方式之一。</p>
<p>看一个 Flink SQL 实现示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- error 日志监控</span></span><br><span class="line"><span class="comment">-- kafka source</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> rcp_server_log (</span><br><span class="line">    thread <span class="type">varchar</span>,</span><br><span class="line">    level <span class="type">varchar</span>,</span><br><span class="line">    loggerName <span class="type">varchar</span>,</span><br><span class="line">    message <span class="type">varchar</span>,</span><br><span class="line">    endOfBatch <span class="type">varchar</span>,</span><br><span class="line">    loggerFqcn <span class="type">varchar</span>,</span><br><span class="line">    instant <span class="type">varchar</span>,</span><br><span class="line">    threadId <span class="type">varchar</span>,</span><br><span class="line">    threadPriority <span class="type">varchar</span>,</span><br><span class="line">    appName <span class="type">varchar</span>,</span><br><span class="line">    triggerTime <span class="keyword">as</span> <span class="built_in">LOCALTIMESTAMP</span>,</span><br><span class="line">    proctime <span class="keyword">as</span> PROCTIME(),</span><br><span class="line"></span><br><span class="line">    WATERMARK <span class="keyword">FOR</span> triggerTime <span class="keyword">AS</span> triggerTime <span class="operator">-</span> <span class="type">INTERVAL</span> <span class="string">&#x27;5&#x27;</span> <span class="keyword">SECOND</span></span><br><span class="line">) <span class="keyword">WITH</span> (</span><br><span class="line">    <span class="string">&#x27;connector.type&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;kafka&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;connector.version&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;0.11&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;connector.topic&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;$&#123;sinkTopic&#125;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;connector.startup-mode&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;latest-offset&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;connector.properties.group.id&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;streaming-metric&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;connector.properties.bootstrap.servers&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;$&#123;sinkBootstrapServers&#125;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;connector.properties.zookeeper.connect&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;$&#123;sinkZookeeperConnect&#125;&#125;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;update-mode&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;append&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;format.type&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;json&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 此处省略 sink_feature_indicator 创建，参考 source table</span></span><br><span class="line"><span class="comment">-- 按天 按城市 各业务线决策分布</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> sink_feature_indicator</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    level,</span><br><span class="line">    loggerName,</span><br><span class="line">    <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> rcp_server_log</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    (level <span class="operator">&lt;&gt;</span> <span class="string">&#x27;INFO&#x27;</span> <span class="keyword">AND</span> `appName` <span class="operator">&lt;&gt;</span> <span class="string">&#x27;AppTestService&#x27;</span>)</span><br><span class="line">    <span class="keyword">OR</span> loggerName <span class="operator">&lt;&gt;</span> <span class="string">&#x27;com.test&#x27;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    TUMBLE(triggerTime, <span class="type">INTERVAL</span> <span class="string">&#x27;5&#x27;</span> <span class="keyword">SECOND</span>),</span><br><span class="line">    level,</span><br><span class="line">    loggerName;</span><br></pre></td></tr></table></figure>

<p>我们在开发 Flink SQL 支持平台过程中，遇到如下问题：</p>
<ul>
<li>一个 SQL 如果清洗一个指标，那么数据源将极大浪费</li>
<li>SQL merge，即一个检测如果同源 SQL 则进行合并，此时将极大增加作业复杂度，且无法定义边界</li>
<li>SQL 上线需要停机重启，此时如果任务中包含大量稳定指标，会不会是临界点</li>
</ul>
<h3 id="技术实现"><a href="#技术实现" class="headerlink" title="技术实现"></a>技术实现</h3><h4 id="痛点总结"><a href="#痛点总结" class="headerlink" title="痛点总结"></a>痛点总结</h4><p><img src="https://cdn.nlark.com/yuque/0/2021/png/694025/1636958712885-c7e2094d-6dfe-460f-ac5a-6a91131f189a.png#clientId=u9f65ab71-ec7d-4&from=paste&height=596&id=u87571ed7&margin=%5Bobject%20Object%5D&name=flink%E5%AE%9E%E6%97%B6%E6%B8%85%E6%B4%97-%E7%97%9B%E7%82%B9.png&originHeight=1191&originWidth=2352&originalType=binary%E2%88%B6=1&size=371328&status=done&style=none&taskId=u1d922219-f96e-4639-8812-0a67475b91f&width=1176" alt="flink实时清洗-痛点.png"><br>业务&amp;研发痛点图</p>
<h4 id="实时计算架构"><a href="#实时计算架构" class="headerlink" title="实时计算架构"></a>实时计算架构</h4><p>策略&#x2F;算法人员每天需要观测实时和离线数据分析线上是否存在风险，针对有风险的场景，会设计防控策略，透传到研发侧其实就是一个个实时特征的开发。所以实时特征的上线速度、质量交付、易用性完全决定了线上风险场景能否及时堵漏的关键。</p>
<p>在统一实时特征计算平台构建之前，实时特征的产出上主要有以下问题：</p>
<ul>
<li>交付速度慢，迭代开发：策略提出到产品，再到研发，提测，在上线观测是否稳定，速度奇慢</li>
<li>强耦合，牵一发动全身：怪兽任务，包含很多业务特征，各业务混在一起，没有优先级保证</li>
<li>重复性开发：由于没有统一的实时特征管理平台，很多特征其实已经存在，只是名字不一样，造成极大浪费</li>
</ul>
<p>平台话建设，最重要的是“<strong>整个流程的抽象”</strong>，平台话的目标应该是能用、易用、好用。基于如上思想，我们尝提取实时特征研发痛点：<strong>模板化 + 配置化</strong>，即平台提供一个实时特征的创建模板，用户基于该模板，可以通过简单的配置即可生成自己需要的实时特征。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/694025/1636889418415-352eaa9b-80b2-4206-ad4a-450dbd71e006.png#clientId=u76bc9eca-51ed-4&from=paste&height=504&id=ua19de657&margin=%5Bobject%20Object%5D&name=flink-dataStream-api.png&originHeight=1007&originWidth=2063&originalType=binary%E2%88%B6=1&size=340898&status=done&style=none&taskId=ue3faa0e7-b516-4129-badb-bafaacccd64&width=1031.5" alt="flink-dataStream-api.png"><br>Flink 实时计算架构图</p>
<h5 id="计算层"><a href="#计算层" class="headerlink" title="计算层"></a>计算层</h5><p><strong>数据源清洗：</strong>不同数据源抽象 Flink Connector，标准输出供下游使用<br><strong>数据拆分：</strong>1 拆 N，一条实时消息可能包含多种消息，此时需要数据裂变<br><strong>动态配置：</strong>允许在不停机 JOB 情况下，动态更新或新增清洗逻辑，涉及特征的清洗逻辑下发<br><strong>脚本加载：</strong>Groovy 支持，热更新<br>**RTC: **即 Real-Time Calculate，实时特征计算，高度抽象的封装模块<br><strong>任务感知：</strong>基于特征业务域、优先级、稳定性，隔离任务，业务解耦</p>
<h5 id="服务层"><a href="#服务层" class="headerlink" title="服务层"></a>服务层</h5><p>**统一查询 SDK: **实时特征统一查询 SDK，屏蔽底层实现逻辑</p>
<p>基于统一的 Flink 实时计算架构，我们重新设计了实时特征清洗架构<br><img src="https://cdn.nlark.com/yuque/0/2021/png/694025/1636947307114-63ee585f-d218-4648-8f4f-712dca858503.png#clientId=u9f65ab71-ec7d-4&from=paste&height=653&id=ua029d7c4&margin=%5Bobject%20Object%5D&name=flink%E5%AE%9E%E6%97%B6%E6%B8%85%E6%B4%97-%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE-2.png&originHeight=1305&originWidth=3583&originalType=binary%E2%88%B6=1&size=653507&status=done&style=none&taskId=u96d9e91f-996f-467b-8055-69f24be1025&width=1791.5" alt="flink实时清洗-数据流图-2.png"><br>Flink 实时计算数据流图</p>
<h5 id="特征配置化-amp-存储-x2F-读取"><a href="#特征配置化-amp-存储-x2F-读取" class="headerlink" title="特征配置化 &amp; 存储&#x2F;读取"></a>特征配置化 &amp; 存储&#x2F;读取</h5><p>特征底层的存储应该是“原子性”的，即最小不可分割单位。为何如此设计？实时统计特征是和窗口大小挂钩的，不同策略人员防控对特征窗口大小有不同的要求，举例如下：</p>
<ul>
<li>可信设备判定场景：其中当前手机号登录时长窗口应适中，不宜过短，防扰动</li>
<li>提现欺诈判定场景：其中当前手机号登录时长窗口应尽量短，短途快速提现的，结合其它维度，快速定位风险</li>
</ul>
<p>基于上述，急需一套通用的实时特征读取模块，满足策略人员任意窗口需求，同时满足研发人员快速的配置清洗需求。我们重构后特征配置模块如下：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/694025/1636815630136-f2e0d640-56b5-4151-8898-4bb443b630fb.png#clientId=u0e262297-22b8-4&from=paste&height=443&id=u9e514356&margin=%5Bobject%20Object%5D&name=image.png&originHeight=885&originWidth=2560&originalType=binary%E2%88%B6=1&size=388262&status=done&style=none&taskId=ub2c4b7c9-15bc-4ea6-877a-a691425095a&width=1280" alt="image.png"><br>特征配置抽象模块</p>
<p>实时特征模块：</p>
<ul>
<li>特征唯一标识</li>
<li>特征名称</li>
<li>是否支持窗口：滑动、滚动、固定大小窗口</li>
<li>事件切片单位：分钟、小时、天、周</li>
<li>主属性：即分组列，可以多个</li>
<li>从属性：聚合函数使用，如去重所需输入基础特征</li>
</ul>
<p>业务留给风控的时间不多，大多数场景在 100 ms 以内，实时特征获取就更短了，从以往的研发经验看，RT 需要控制在 10 ms 以内，以确保策略执行不会超时。所以我们的存储使用 Redis，确保性能不是瓶颈。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/694025/1636853909253-70a7b3eb-c0f6-432e-bdf3-a4da74d504ec.png#clientId=u0e262297-22b8-4&from=paste&height=720&id=uc556f9c2&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1440&originWidth=2253&originalType=binary%E2%88%B6=1&size=396422&status=done&style=none&taskId=ud75d2ed0-a961-4214-a9d7-eef8b546249&width=1126.5" alt="image.png"></p>
<h5 id="清洗脚本热部署"><a href="#清洗脚本热部署" class="headerlink" title="清洗脚本热部署"></a>清洗脚本热部署</h5><p>如上述，实时特征计算模块强依赖于上游消息内传递的“主属性” 和 “从属性”，此阶段也是研发需要介入的地方，如果消息内主属性字段不存在，则需要研发补全，此时不得不加入代码的发版，那又会回到原始阶段面临的问题：Flink Job 需要不停的重启，这显然是不能接受的。<br>此时我们想到了 Groovy，能否让 Flink + Groovy，直接热部署代码？答案是肯定的！</p>
<p>由于我们抽象了整个 Flink Job 的计算流图，算子本身是不需要变更的，即 DAG 是固定不变的，变得是算子内部关联事件的清洗逻辑。所以，只要关联清洗逻辑和清洗代码本身变更，即不需要重启 Flink Job 完成热部署。</p>
<p>Groovy 热部署核心逻辑如图所示：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/694025/1636961737804-c06a5806-ae76-4952-ae8a-5d538ac65bdc.png#clientId=u9f65ab71-ec7d-4&from=paste&height=285&id=uf340b748&margin=%5Bobject%20Object%5D&name=flink%E5%AE%9E%E6%97%B6%E6%B8%85%E6%B4%97-%E8%84%9A%E6%9C%AC%E9%85%8D%E7%BD%AE.png&originHeight=569&originWidth=3384&originalType=binary%E2%88%B6=1&size=289619&status=done&style=none&taskId=uf6d2f1f5-021b-4df4-8f69-293e81024ff&width=1692" alt="flink实时清洗-脚本配置.png"><br>清洗脚本配置与加载图</p>
<p>研发或策略人员在管理后台（Operating System）添加清洗脚本，并存入数据库。Flink Job 脚本缓存模块此时会感知脚本的新增或修改（如何感知看下文整体流程详解）</p>
<ul>
<li>warm up：脚本首次运行较耗时，首次启动或者缓存更新时提前预热执行，保证真实流量进入脚本快速执行</li>
<li>cache：缓存已经在好的 Groovy 脚本</li>
<li>Push&#x2F;Poll：缓存更新采用推拉两种模式，确保信息不回丢失</li>
<li>router：脚本路由，确保消息能寻找到对应脚本并执行</li>
</ul>
<p>脚本加载核心代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓存，否则无限加载下去会 metaspace outOfMemory</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Map&lt;String, GroovyObject&gt; groovyObjectCache = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 加载脚本</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> script</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> GroovyObject <span class="title function_">buildScript</span><span class="params">(String script)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (StringUtils.isEmpty(script)) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;script is empty&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="type">String</span> <span class="variable">cacheKey</span> <span class="operator">=</span> DigestUtils.md5DigestAsHex(script.getBytes());</span><br><span class="line">       <span class="keyword">if</span> (groovyObjectCache.containsKey(cacheKey)) &#123;</span><br><span class="line">           log.debug(<span class="string">&quot;groovyObjectCache hit&quot;</span>);</span><br><span class="line">           <span class="keyword">return</span> groovyObjectCache.get(cacheKey);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="type">GroovyClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GroovyClassLoader</span>();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Class&lt;?&gt; groovyClass = classLoader.parseClass(script);</span><br><span class="line">           <span class="type">GroovyObject</span> <span class="variable">groovyObject</span> <span class="operator">=</span> (GroovyObject) groovyClass.newInstance();</span><br><span class="line">           classLoader.clearCache();</span><br><span class="line"></span><br><span class="line">           groovyObjectCache.put(cacheKey, groovyObject);</span><br><span class="line">           log.info(<span class="string">&quot;groovy buildScript success: &#123;&#125;&quot;</span>, groovyObject);</span><br><span class="line">           <span class="keyword">return</span> groovyObject;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;buildScript error&quot;</span>, e);</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               classLoader.close();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">               log.error(<span class="string">&quot;close GroovyClassLoader error&quot;</span>, e);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="标准消息-amp-清洗流程"><a href="#标准消息-amp-清洗流程" class="headerlink" title="标准消息 &amp; 清洗流程"></a>标准消息 &amp; 清洗流程</h5><p>策略需要统计的消息维度很杂，涉及多个业务，研发本身也有监控用到的实时特征需求。所以实时特征对应的数据源是多种多样的。所幸 Flink 是支持多种数据源接入的，对于一些特定的数据源，我们只需要继承实现 Flink Connector 即可满足需求，我将拿 Kafka 举例，整体流程是如何清洗实时统计特征的。</p>
<p>首先介绍风控整体数据流，多个业务场景对接风控中台，风控内部核心链路是：决策引擎、规则引擎、特征服务。<br>一次业务请求决策，我们会异步记录下来，并发送 Kafka 消息，用于实时特征计算 &amp; 离线埋点。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/694025/1636467154545-6c6b6439-bde2-4666-866b-70a840ffddce.png#clientId=u2328e012-2b0c-4&from=paste&height=1201&id=TiwBU&margin=%5Bobject%20Object%5D&name=image.png&originHeight=2401&originWidth=3414&originalType=binary%E2%88%B6=1&size=2673613&status=done&style=none&taskId=uf83fbded-b33d-4215-b3b4-c8ba299ef7d&width=1707" alt="image.png"><br>风控核心数据流图</p>
<h6 id="标准化消息模板"><a href="#标准化消息模板" class="headerlink" title="标准化消息模板"></a>标准化消息模板</h6><p>Flink 实时计算 Job 在接收到 MQ 消息后，首先是消息模板标准化解析，不同的 Topic 对应消息格式不一致，JSON、CSV、异构（如错误日志类消息，空格隔断，对象内包含 JSON 对象）等。</p>
<p>为方便下游算子统一处理，标准化后消息结构如下 JSON 结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RcpPreProcessData</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 渠道，可以直接写topic即可</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String channel;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息分类 channel + eventCode 应唯一确定一类消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String eventCode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 所有主从属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; featureParamMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 原始消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ObjectNode node;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="消息裂变"><a href="#消息裂变" class="headerlink" title="消息裂变"></a>消息裂变</h6><p>一条“富消息”可能包含大量的业务信息，某些实时特征可能需要分别统计。举例，一条业务请求风控的上下文消息，包含本次消息是否拒绝，即命中了多少策略规则，命中的规则是数组，可能包含多条命中规则。此时如果想基于一条命中的规则去关联其它属性统计，就需要用到消息的裂变，由 1 变 N。</p>
<p>消息裂变的逻辑由运营后台通过 Groovy 脚本编写，定位清洗脚本逻辑则是 channel（父） + eventCode（子），此处寻找逻辑分“父子”，“父”逻辑对当前 channel 下所有逻辑适用，避免单独配置 N 个 eventCode 的繁琐，“子”逻辑则对特定的 eventCode 适用。</p>
<h6 id="消息清洗-amp-剪枝"><a href="#消息清洗-amp-剪枝" class="headerlink" title="消息清洗 &amp; 剪枝"></a>消息清洗 &amp; 剪枝</h6><p>消息的清洗就是我们需要知道特征需要哪些主从属性，带着目的清洗更清晰，定位清洗的脚本同上，依然依据 channel + eventCode 实现。清洗出的主从属性存在 featureParamMap 中，供下游实时计算使用。</p>
<p>此处需要注意的是，我们一直是带着原始消息向下传递的，但如果已经确认了清洗的主从属性，那么原始消息就没有存在的必要了，此时我们需要“剪枝”，节省 RPC 调用过程 I&#x2F;O 流量的消耗。</p>
<p>至此，一条原始消息已经加工成只包含 channel（渠道）、eventCode（事件类型）、featureParamMap（所有主从属性），下游算子只需要且仅需要这些信息即可计算。</p>
<h6 id="实时计算"><a href="#实时计算" class="headerlink" title="实时计算"></a>实时计算</h6><p>依然同上面两个算子，实时计算算子依赖 channel + eventCode 查找到对应实时特征元数据，一个事件可能存在多个实时特征配置，运营平台填写好实时特征配置后，依据缓存更新机制，快速分发到任务中，依据 Key 构造器 生成对应的 Key，传递下游直接 Sink 到 Redis 中。</p>
<h3 id="任务问题排查-amp-调优思路"><a href="#任务问题排查-amp-调优思路" class="headerlink" title="任务问题排查&amp;调优思路"></a>任务问题排查&amp;调优思路</h3><p>任务的排查是基于完善的监控上实现的，Flink 提供了很多有用的 Metric 供我们排查问题，如下是我罗列的常见的任务异常，希望对你有所帮助。</p>
<h4 id="TaskManager-Full-GC-问题排查"><a href="#TaskManager-Full-GC-问题排查" class="headerlink" title="TaskManager Full GC 问题排查"></a>TaskManager Full GC 问题排查</h4><p>出现上面这个异常的可能原因是因为：</p>
<ul>
<li>大窗口：90% TM 内存爆表，都是大窗口导致的</li>
<li>内存泄漏：如果是自定义节点，且涉及到缓存等很容易导致内存膨胀</li>
</ul>
<p>解决办法：</p>
<ul>
<li>合理制定窗口导线，合理分配 TM 内存（1.10 默认是 1G），聚合数据应交由 Back State 管理，不建议自己写对象存储</li>
<li>可 attach heap 快照排查异常，分析工具如 MAT，需要一定的调优经验，也能快速定位问题</li>
</ul>
<h4 id="Flink-Job-反压"><a href="#Flink-Job-反压" class="headerlink" title="Flink Job 反压"></a>Flink Job 反压</h4><p>出现上面这个异常的可能原因是因为：</p>
<ul>
<li>数据倾斜：90%的反压，一定是数据倾斜导致的</li>
<li>并行度并未设置好，错误估计数据流量或单个算子计算性能</li>
</ul>
<p>解决办法：</p>
<ul>
<li>数据清洗参考下文</li>
<li>对于并行度，可以在消息传递过程中埋点，看各个节点 cost</li>
</ul>
<h4 id="数据倾斜"><a href="#数据倾斜" class="headerlink" title="数据倾斜"></a>数据倾斜</h4><p>核心思路：</p>
<ul>
<li>key 加随机数，然后执行 keyby 时会根据新 key 进行分区，此时会打散 key 的分布，不会造成数据倾斜问题</li>
<li>二次 keyby 进行结果统计</li>
</ul>
<p>打散逻辑核心代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KeyByRouter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">SPLIT_CHAR</span> <span class="operator">=</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不能太散，否则二次聚合还是会有数据倾斜</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sourceKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">randomKey</span><span class="params">(String sourceKey)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">endExclusive</span> <span class="operator">=</span> (<span class="type">int</span>) Math.pow(<span class="number">2</span>, <span class="number">7</span>);</span><br><span class="line">        <span class="keyword">return</span> sourceKey + SPLIT_CHAR + (RandomUtils.nextInt(<span class="number">0</span>, endExclusive) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">restoreKey</span><span class="params">(String randomKey)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(randomKey)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> randomKey.split(SPLIT_CHAR)[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="作业暂停并保留状态失败"><a href="#作业暂停并保留状态失败" class="headerlink" title="作业暂停并保留状态失败"></a>作业暂停并保留状态失败</h4><p>出现上面这个异常的可能原因是因为：</p>
<ul>
<li>作业本身处于反压的情况，做 Checkpoint 可能失败了，所以暂停保留状态的时候做 Savepoint 肯定也会失败</li>
<li>作业的状态很大，做 Savepoint 超时了</li>
<li>作业设置的 Checkpoint 超时时间较短，导致 SavePoint 还没有做完，作业就丢弃了这次 Savepoint 的状态</li>
</ul>
<p>解决办法：</p>
<ul>
<li>代码设置 Checkpoint 的超时时间尽量的长一些，比如 10min，对于状态很大的作业，可以设置更大</li>
<li>如果作业不需要保留状态，那么直接暂停作业，然后重启就行</li>
</ul>
<h3 id="总结与展望"><a href="#总结与展望" class="headerlink" title="总结与展望"></a>总结与展望</h3><p>这篇文章分别从实时特征清洗框架演进，特征可配置，特征清洗逻辑热部署等方面介绍了目前较稳定的实时计算可行架构。经过近两年的迭代，目前这套架构在稳定性、资源利用率、性能开销上有最优的表现，给业务策略人员及业务算法人员提供了有力的支撑。</p>
<p>未来，我们期望特征的配置还是回归 SQL 化，虽然目前配置已经足够简单，但是毕竟属于我们自己打造的“领域设计语言”，对新来的的策略人员 &amp; 产品人员有一定的学习成本，我们期望的是能够通过像 SQL 这种全域通过用语言来配置化，类似 Hive 离线查询一样，屏蔽了底层复杂的计算逻辑，助力业务更好的发展。</p>
<p>参考文献：<br>[1] 风险管控（<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%A3%8E%E9%99%A9%E7%AE%A1%E7%90%86">https://zh.wikipedia.org/wiki/%E9%A3%8E%E9%99%A9%E7%AE%A1%E7%90%86</a>）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="是咕咕鸡"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">是咕咕鸡</p>
  <div class="site-description" itemprop="description">过刚易折，善柔不败</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">是咕咕鸡</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
