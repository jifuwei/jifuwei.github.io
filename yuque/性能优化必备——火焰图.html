<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="ZAxoxqp0q8qf8GaVFBLqt3fZ2g3Ch1QtMgFoQhUyzZQ">
  <meta name="baidu-site-verification" content="code-YeeuLMqwzd">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jifuwei.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="引言本文主要介绍火焰图及使用技巧，学习如何使用火焰图快速定位软件的性能卡点。结合最佳实践实战案例，帮助读者加深刻的理解火焰图构造及原理，理解 CPU 耗时，定位性能瓶颈。 背景当前现状假设没有火焰图，你是怎么调优程序代码的呢？让我们来捋一下。 1. 功能开关法想当年我刚工作，还是一个技术小白时，排查问题只能靠玄学，大致能猜出问题可能是由某个功能代码导致的，此时的排查手段就是删除多余的功能代码，然后">
<meta property="og:type" content="article">
<meta property="og:title" content="性能优化必备——火焰图">
<meta property="og:url" content="https://jifuwei.github.io/yuque/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%BF%85%E5%A4%87%E2%80%94%E2%80%94%E7%81%AB%E7%84%B0%E5%9B%BE.html">
<meta property="og:site_name" content="是咕咕鸡">
<meta property="og:description" content="引言本文主要介绍火焰图及使用技巧，学习如何使用火焰图快速定位软件的性能卡点。结合最佳实践实战案例，帮助读者加深刻的理解火焰图构造及原理，理解 CPU 耗时，定位性能瓶颈。 背景当前现状假设没有火焰图，你是怎么调优程序代码的呢？让我们来捋一下。 1. 功能开关法想当年我刚工作，还是一个技术小白时，排查问题只能靠玄学，大致能猜出问题可能是由某个功能代码导致的，此时的排查手段就是删除多余的功能代码，然后">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jfw-blog-1313671624.cos.ap-nanjing.myqcloud.com/undefined/FtdWCI7ew4mdwb0SO9EJ5B971y9x.png">
<meta property="og:image" content="https://jfw-blog-1313671624.cos.ap-nanjing.myqcloud.com/undefined/Fn4EAu62gT37YPYbkoWo4--dEOub.png">
<meta property="og:image" content="https://jfw-blog-1313671624.cos.ap-nanjing.myqcloud.com/undefined/FuXnmpyhqPp60nQr7wk_hQe4g1ip.png">
<meta property="og:image" content="https://jfw-blog-1313671624.cos.ap-nanjing.myqcloud.com/undefined/FuR5A0LQC8t-HFh2RFdbNy3ggRqJ.png">
<meta property="og:image" content="https://jfw-blog-1313671624.cos.ap-nanjing.myqcloud.com/undefined/FplZzX6ilxAZsyi43GkWlZ4Oj-Gd.png">
<meta property="og:image" content="https://jfw-blog-1313671624.cos.ap-nanjing.myqcloud.com/undefined/FrdoRUowsniGDFkckvxHzoV0cyRj.png">
<meta property="og:image" content="https://jfw-blog-1313671624.cos.ap-nanjing.myqcloud.com/undefined/Ft3do38KjB_k7KFTdbTuvyClC5JR.png">
<meta property="article:published_time" content="2022-08-28T06:38:15.000Z">
<meta property="article:modified_time" content="2022-09-02T15:51:46.322Z">
<meta property="article:author" content="是咕咕鸡">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jfw-blog-1313671624.cos.ap-nanjing.myqcloud.com/undefined/FtdWCI7ew4mdwb0SO9EJ5B971y9x.png">

<link rel="canonical" href="https://jifuwei.github.io/yuque/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%BF%85%E5%A4%87%E2%80%94%E2%80%94%E7%81%AB%E7%84%B0%E5%9B%BE.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>性能优化必备——火焰图 | 是咕咕鸡</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?1575500ddb979a8e4e895121cbd848cb";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">是咕咕鸡</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">希望我分享的文章能够给每一位读者带来帮助！</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jifuwei.github.io/yuque/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%BF%85%E5%A4%87%E2%80%94%E2%80%94%E7%81%AB%E7%84%B0%E5%9B%BE.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="是咕咕鸡">
      <meta itemprop="description" content="过刚易折，善柔不败">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="是咕咕鸡">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          性能优化必备——火焰图
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-28 14:38:15" itemprop="dateCreated datePublished" datetime="2022-08-28T14:38:15+08:00">2022-08-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-02 23:51:46" itemprop="dateModified" datetime="2022-09-02T23:51:46+08:00">2022-09-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>本文主要介绍火焰图及使用技巧，学习如何使用火焰图快速定位软件的性能卡点。<br>结合最佳实践实战案例，帮助读者加深刻的理解火焰图构造及原理，理解 CPU 耗时，定位性能瓶颈。</p>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><h4 id="当前现状"><a href="#当前现状" class="headerlink" title="当前现状"></a>当前现状</h4><p>假设没有火焰图，你是怎么调优程序代码的呢？让我们来捋一下。</p>
<h5 id="1-功能开关法"><a href="#1-功能开关法" class="headerlink" title="1. 功能开关法"></a>1. 功能开关法</h5><p>想当年我刚工作，还是一个技术小白时，排查问题只能靠玄学，大致能猜出问题可能是由某个功能代码导致的，此时的排查手段就是删除多余的功能代码，然后再运行查看 CPU 消耗，确定问题。（至今我工作时还会发现一些老人使用如此方法调试性能。）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (关闭<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 功能1</span></span><br><span class="line">        handle1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (关闭<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 功能2</span></span><br><span class="line">        handle2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (打开<span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">// 功能3</span></span><br><span class="line">        handle3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 功能4</span></span><br><span class="line">    handle4();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此法全靠“经验”和“运气”，而且改动了代码结构，假设这是一个已经通过测试的集成区代码，此时需要修改代码功能来调试程序是非常危险的一件事，当然有 Git 仓库可以“一键还原”，但是，是人操作，总归会有失手的时候，且定位效率太低</p>
<h5 id="2-StopWatch-埋点法"><a href="#2-StopWatch-埋点法" class="headerlink" title="2. StopWatch 埋点法"></a>2. StopWatch 埋点法</h5><p>当程序出现性能问题时，且不确定是哪一段代码导致耗时，可以借助方法耗时来判断，此时我们只要在调用方法前后追加执行所需耗时日志，即可判定到底是哪个方法最耗时。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Stopwatch</span> <span class="variable">stopwatch</span> <span class="operator">=</span> Stopwatch.createStarted();</span><br><span class="line">    handle1();</span><br><span class="line">	log.info(<span class="string">&quot;method handle1 cost: &#123;&#125; ms&quot;</span>,</span><br><span class="line">             stopwatch.elapsed(TimeUnit.MILLISECONDS));</span><br><span class="line"></span><br><span class="line">    handle2();</span><br><span class="line">    log.info(<span class="string">&quot;method handle2 cost: &#123;&#125; ms&quot;</span>,</span><br><span class="line">             stopwatch.elapsed(TimeUnit.MILLISECONDS));</span><br><span class="line"></span><br><span class="line">    handle3();</span><br><span class="line">    log.info(<span class="string">&quot;method handle3 cost: &#123;&#125; ms&quot;</span>,</span><br><span class="line">             stopwatch.elapsed(TimeUnit.MILLISECONDS));</span><br><span class="line"></span><br><span class="line">    handle4();</span><br><span class="line">    log.info(<span class="string">&quot;method handle4 cost: &#123;&#125; ms&quot;</span>,</span><br><span class="line">             stopwatch.stop().elapsed(TimeUnit.MILLISECONDS));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此法较上一个方法的优势是，不改变代码的逻辑情况下，只是增强了一些观测点位，由方法的耗时来定位性能瓶颈。但是，假设方法的处理调用栈很深，就不得不在子方法中再次埋点，此时判定流程即为：埋点 -&gt; 发版 -&gt; 定位 -&gt; 埋点 -&gt; 发版 -&gt; 定位 -&gt; …….且本质上也是改了代码，就有出错的可能。 心累，不高效！</p>
<h5 id="3-TOP-命令定位热线程"><a href="#3-TOP-命令定位热线程" class="headerlink" title="3. TOP 命令定位热线程"></a>3. TOP 命令定位热线程</h5><p>一般企业的软件服务都是部署在 Linux 操作系统上，有经验的老手排查性能最方便的办法就是 top 定位。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -p pid -H</span><br></pre></td></tr></table></figure>

<p><img src="https://jfw-blog-1313671624.cos.ap-nanjing.myqcloud.com/undefined/FtdWCI7ew4mdwb0SO9EJ5B971y9x.png"><br>明显看到，pid 103 消耗了 40%的 CPU, 找到对应的 stack 线程信息如下（忽略查找办法，我假设你已经会了：））：<br><img src="https://jfw-blog-1313671624.cos.ap-nanjing.myqcloud.com/undefined/Fn4EAu62gT37YPYbkoWo4--dEOub.png"><br>此时可以得出结论，当前最耗 CPU 的线程是写入磁盘文件，追查代码最终会定位到是因为在高并发场景下打了大量的 INFO 日志，导致磁盘写入成为瓶颈。</p>
<p>总结：TOP 命令对于找 CPU 性能瓶颈时很有效的，但是存在如下几个问题：</p>
<ul>
<li>排名最前的一定是当时最消耗 CPU 的，但不一定是程序性能的诱因。例如因某个 BUG 导致打印了大量 ERROR 日志，最终 LOG 到磁盘是最消耗 CPU 的，但罪魁祸首不是它。</li>
<li>TOP 注定使你只会关注最高的，等你修复最耗 CPU 的问题后，往往还会遇到别的程序问题导致 CPU 偏高，即一次只能看到一个问题，看不到全貌。</li>
<li>文本的表现力非常有限：首先你得对 Linux 及 JVM 命令非常熟悉，其次文本对两个及以上值做关联性分析时，就捉襟见肘了，此时就迫切的需要另一种分析工具——图。</li>
</ul>
<h3 id="什么是火焰图"><a href="#什么是火焰图" class="headerlink" title="什么是火焰图"></a>什么是火焰图</h3><p>火焰图（<a target="_blank" rel="noopener" href="https://www.brendangregg.com/flamegraphs.html">Flame Graphs</a>），因其形似火焰而得名。<br><img src="https://jfw-blog-1313671624.cos.ap-nanjing.myqcloud.com/undefined/FuXnmpyhqPp60nQr7wk_hQe4g1ip.png"></p>
<p>如上就是一个典型的火焰图，它由各种大小&#x2F;颜色的方块组成，每个方块内部还标识了文字，整个图片顶部凹凸不平，形似一簇簇“火苗”，因此得名火焰图。<br>火焰图是 SVG 生成，因此可以与用户互动，鼠标悬浮在某个方块时，会详细展示内部文字。点击后，即会以当前被点击方块为底向上展开。</p>
<p><strong>特征</strong><br>使用火焰图分析之前，我们得首先了解火焰图的基本构造</p>
<ul>
<li>每一列代表一个调用栈，每一格代表一个被调用函数</li>
<li>方块上的字符标识调用方法，数字表示当前采样出现次数</li>
<li>Y 轴表示调用栈深度，X 轴将多个调用栈归并，并首字母排序展示</li>
<li>X 轴宽度表示采样数据中出现频次，即宽度越大，导致性能瓶颈的原因可能就越大（<strong>注意：是可能，不是确定</strong>）</li>
<li>颜色没什么意义，随机分配（可能创始人想让你看起来更像一个火焰。。）</li>
</ul>
<h3 id="火焰图可以做什么"><a href="#火焰图可以做什么" class="headerlink" title="火焰图可以做什么"></a>火焰图可以做什么</h3><p>那此时你已经知道了火焰图，如何定位软件问题呢？我们需要一套寻找性能瓶颈的方法论。<br>可以明确的是 CPU 消耗高的口径</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CPU 消耗高的口径 = 调用栈出现频率最高的一定是吃 CPU 的</span><br></pre></td></tr></table></figure>

<p>如上我们已经知道了火焰图的构造，及“物料”含义，此时我们的关注点应该在方形的宽度上，方形的宽度大小代表了该调用栈在整个抽样历史中出现的次数。次数意味着频率，即出现次数越多的即可能最消耗 CPU。<br><img src="https://jfw-blog-1313671624.cos.ap-nanjing.myqcloud.com/undefined/FuR5A0LQC8t-HFh2RFdbNy3ggRqJ.png"><br>但只关注最长的是没用的，如底部的 root 和中部的方块都很宽，只能说明这些方法是“入口方法”，即每次发起调用都会经过的方法。<br>我们更应该关注火焰山顶部的”<strong>平顶山</strong>“（plateaus）<strong>出现的次数多，即没有子调用</strong>，抽样出现的频率高，说明执行方法的时间较长，或者执行频率太高（如长轮询），即 CPU 大部分执行都分配给了“平顶山”，它才是性能瓶颈的根因。</p>
<p><strong>总结方法论：火焰图看“平顶山”，山顶的函数可能存在性能问题！</strong></p>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>实践是检验真理的唯一标准！下面我将以一个小的 Demo 来展示如何定位程序性能问题，加深对火焰图使用的理解。</p>
<p>Demo 程序如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            executorService.submit(Demo::handle1);</span><br><span class="line">            executorService.submit(Demo::handle2);</span><br><span class="line">            executorService.submit(Demo::handle3);</span><br><span class="line">            executorService.submit(Demo::handle4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handle4</span><span class="params">()</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handle2</span><span class="params">()</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">50</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handle3</span><span class="params">()</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handle1</span><span class="params">()</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">50</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很简单，当然现实中也不会这么写，主要是配合演出。。<br>主要是开了一个线程池，且分别执行四个 task，不同的 task 耗时不一致，此时我们的性能瓶颈在 handle4 这个任务上，在知道结论的前提下，我们比较看火焰图得出答案的是否符合预期！</p>
<h4 id="1-JVM-堆栈信息拉取"><a href="#1-JVM-堆栈信息拉取" class="headerlink" title="1. JVM 堆栈信息拉取"></a>1. JVM 堆栈信息拉取</h4><p>当前我是在自己的 Mac 上运行的程序，idea 执行这一段程序非常便捷，那如何获取当前运行 main 函数的 PID？<br>此时需要用到 TOP 命令，上面是个 while 死循环，很明显吃 CPU 最厉害，只要找到归属 Java 线程的最高一个 PID 即为所求。<br><img src="https://jfw-blog-1313671624.cos.ap-nanjing.myqcloud.com/undefined/FplZzX6ilxAZsyi43GkWlZ4Oj-Gd.png"><br>很明显得到 COMMAND &#x3D; java 最高的 PID &#x3D; 20552<br>此时执行如下命令获取堆栈信息，并写入 tmp.txt 文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack -l 20552 &gt; tmp.txt</span><br></pre></td></tr></table></figure>

<h4 id="2-生成火焰图"><a href="#2-生成火焰图" class="headerlink" title="2. 生成火焰图"></a>2. 生成火焰图</h4><p>生成火焰图的工具有很多，我一般会借助 <a target="_blank" rel="noopener" href="https://www.fastthread.io/">FastThread</a>，在线分析堆栈，非常方便，同时支持生成火焰图，方便我们定位问题<br><img src="https://jfw-blog-1313671624.cos.ap-nanjing.myqcloud.com/undefined/FrdoRUowsniGDFkckvxHzoV0cyRj.png"><br>打开官网首页，选择刚刚 dump 的堆栈文件，点击 Analyze，此时只需要等待网站分析好后（正常 3~5 s），即可查看火焰图</p>
<p>fastThread 网站分析报告非常丰富，一般的问题我们直接通过它给出的结论基本能定位到问题了，本文暂且无需关注，感兴趣的话，后续我会分享，直接拉到 Flame Graph 子标题处<br><img src="https://jfw-blog-1313671624.cos.ap-nanjing.myqcloud.com/undefined/Ft3do38KjB_k7KFTdbTuvyClC5JR.png"><br>此时明显能看出 4 个“平顶山”，且 com.Demo.handle4 宽度最大，com.Demo.handle3 次之，符合预期！</p>
<h3 id="原理剖析"><a href="#原理剖析" class="headerlink" title="原理剖析"></a>原理剖析</h3><p>基于上述小 Demo ，我们深入理解下火焰图的生成原理。</p>
<p>举个例子，便于你理解，假设我们要观测一个人在忙些什么，哪些事最占用他的时间，会怎么做？<br>从时间维度的话，且不考虑成本的话，我肯定安排一个监控摄像头，全天候 24h，360 度监控他，然后再安排人员，逐帧排查，并汇总他所做的事，得出：睡觉 8h，工作 8h，玩手机 4h，吃饭 2h，其它 2h。从而得出结论：睡觉占用他时间最多。</p>
<p>由上可以总结一套分析流程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">记录（监控）-&gt; 分析&amp;归并（逐帧排查） -&gt;  Top N -&gt; 得出结论</span><br></pre></td></tr></table></figure>

<p>带着流程去看我们应该如何排查 CPU 在执行中，哪些事（进程&#x2F;线程）最占用它的时间呢？<br>简单粗暴的方法是每时每刻都记录执行的方法堆栈，再汇总归并，得出最耗时的方法栈在哪。此法的问题在于</p>
<ul>
<li>数据量大</li>
<li>时间长</li>
</ul>
<p>其实只要采样去观测 CPU 在干什么就好了，这是一个概率学问题，如果 CPU 因为执行某个方法耗时，大概率采样下来，得到的归并结果也是最多的，虽然有误差，但是多次统计下，差不了多少的。<br>同理，dump 下的堆栈，查看大多数线程在干什么，依据堆栈内每个方法出现的频率聚合，出现的频次最多的就是当前 CPU 分配执行最多的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;pool-1-thread-18&quot;</span> #<span class="number">28</span> prio=<span class="number">5</span> os_prio=<span class="number">31</span> tid=<span class="number">0x00007f9a8d4c0000</span> nid=<span class="number">0x8d03</span> sleeping[<span class="number">0x000000030be59000</span>]</span><br><span class="line">    java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class="line">    at java.lang.Thread.sleep(Native Method)</span><br><span class="line">    at com.Demo.handle2(Demo.java:<span class="number">31</span>)</span><br><span class="line">    at com.Demo$$Lambda$<span class="number">2</span>/<span class="number">1277181601.</span>run(Unknown Source)</span><br><span class="line">    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:<span class="number">511</span>)</span><br><span class="line">    at java.util.concurrent.FutureTask.run(FutureTask.java:<span class="number">266</span>)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1149</span>)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">624</span>)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"></span><br><span class="line">    Locked ownable synchronizers:</span><br><span class="line">- &lt;<span class="number">0x00000006c6921ac0</span>&gt; (a java.util.concurrent.ThreadPoolExecutor$Worker)</span><br></pre></td></tr></table></figure>

<p>至于我们的 jstack 信息如何被处理成火焰图的格式，社区已经为常见的 dump 格式都提供了工具，<a target="_blank" rel="noopener" href="https://github.com/brendangregg/FlameGraph/blob/master/stackcollapse-jstack.pl">stackcollapse-jstack.pl</a> 处理 jstack 输出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Example input:</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;MyProg&quot;</span> #<span class="number">273</span> daemon prio=<span class="number">9</span> os_prio=<span class="number">0</span> tid=<span class="number">0x00007f273c038800</span> nid=<span class="number">0xe3c</span> runnable [<span class="number">0x00007f28a30f2000</span>]</span><br><span class="line">    java.lang.Thread.State: RUNNABLE</span><br><span class="line">        at java.net.SocketInputStream.socketRead0(Native Method)</span><br><span class="line">        at java.net.SocketInputStream.read(SocketInputStream.java:<span class="number">121</span>)</span><br><span class="line">        ...</span><br><span class="line">        at java.lang.Thread.run(Thread.java:<span class="number">744</span>)</span><br><span class="line"></span><br><span class="line">Example output:</span><br><span class="line"></span><br><span class="line">MyProg;java.lang.Thread.run;java.net.SocketInputStream.read;java.net.SocketInputStream.socketRead0 <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="总结-amp-展望"><a href="#总结-amp-展望" class="headerlink" title="总结&amp;展望"></a>总结&amp;展望</h3><p>火焰图的介绍到此结束，相信你又多了一种排查问题的手段！<br>存在即合理，工具之开发重要性而言不必多说，我始终持包容态度面对新事物，它确确实实解决了某些痛点而脱颖而出的。<br>后续我会介绍更多排查问题的手段，如果你喜欢本文风格，请关注或留言，欢迎讨论！</p>

    </div>

    
    
    
        <div class="reward-container">
  <div>原创技术分享，您的支持鼓励是我继续创作的动力！</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechat.jpg" alt="是咕咕鸡 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="是咕咕鸡 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/images/wechat_channel.png">
            <span class="icon">
              <i class="fab fa-weixin"></i>
            </span>

            <span class="label">WeChat</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/yuque/Flink%20%E5%9C%A8%E9%A3%8E%E6%8E%A7%E5%9C%BA%E6%99%AF%E5%AE%9E%E6%97%B6%E7%89%B9%E5%BE%81%E8%90%BD%E5%9C%B0%E5%AE%9E%E6%88%98.html" rel="prev" title="Flink 在风控场景实时特征落地实战">
      <i class="fa fa-chevron-left"></i> Flink 在风控场景实时特征落地实战
    </a></div>
      <div class="post-nav-item">
    <a href="/yuque/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E2%80%94%E2%80%94%E5%B0%8F%E5%B0%8F%E7%9A%84log%E5%A4%A7%E5%A4%A7%E7%9A%84%E5%9D%91.html" rel="next" title="性能调优——小小的log大大的坑">
      性能调优——小小的log大大的坑 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%83%8C%E6%99%AF"><span class="nav-number">2.</span> <span class="nav-text">背景</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BD%93%E5%89%8D%E7%8E%B0%E7%8A%B6"><span class="nav-number">2.1.</span> <span class="nav-text">当前现状</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%8A%9F%E8%83%BD%E5%BC%80%E5%85%B3%E6%B3%95"><span class="nav-number">2.1.1.</span> <span class="nav-text">1. 功能开关法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-StopWatch-%E5%9F%8B%E7%82%B9%E6%B3%95"><span class="nav-number">2.1.2.</span> <span class="nav-text">2. StopWatch 埋点法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-TOP-%E5%91%BD%E4%BB%A4%E5%AE%9A%E4%BD%8D%E7%83%AD%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.1.3.</span> <span class="nav-text">3. TOP 命令定位热线程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%81%AB%E7%84%B0%E5%9B%BE"><span class="nav-number">3.</span> <span class="nav-text">什么是火焰图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%81%AB%E7%84%B0%E5%9B%BE%E5%8F%AF%E4%BB%A5%E5%81%9A%E4%BB%80%E4%B9%88"><span class="nav-number">4.</span> <span class="nav-text">火焰图可以做什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-number">5.</span> <span class="nav-text">最佳实践</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-JVM-%E5%A0%86%E6%A0%88%E4%BF%A1%E6%81%AF%E6%8B%89%E5%8F%96"><span class="nav-number">5.1.</span> <span class="nav-text">1. JVM 堆栈信息拉取</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E7%94%9F%E6%88%90%E7%81%AB%E7%84%B0%E5%9B%BE"><span class="nav-number">5.2.</span> <span class="nav-text">2. 生成火焰图</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90"><span class="nav-number">6.</span> <span class="nav-text">原理剖析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-amp-%E5%B1%95%E6%9C%9B"><span class="nav-number">7.</span> <span class="nav-text">总结&amp;展望</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="是咕咕鸡"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">是咕咕鸡</p>
  <div class="site-description" itemprop="description">过刚易折，善柔不败</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/jifuwei" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jifuwei" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">是咕咕鸡</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>















  

  

</body>
</html>
